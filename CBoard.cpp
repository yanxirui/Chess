#pragma once

#include "stdafx.h"
#include "CBoard.h"
#include <cstring>

//-------------------变量定义--------------------------------------


//走法函数相关数组-------------------------------------------

//对于某一位置的棋子，其对应的可以走的位置和当前位置的数字差
//各种棋子走法数组
// 评估辅助数组
const short PieceValue[8] = { 1000,20,20,40,90,45,10,0 }; //棋子价值表

														  //各种棋子走法数组
short KingDir[8] = { -0x10,		-0x01,	+0x01,	+0x10,	0,		0,		0,		0 },//将
AdvisorDir[8] = { -0x11,		-0x0f,	+0x0f,	+0x11,	0,		0,		0,		0 },		//士
BishopDir[8] = { -0x22,		-0x1e,	+0x1e,	+0x22,	0,		0,		0,		0 },	//象
KnightDir[8] = { -0x21,		-0x1f,	-0x12,	-0x0e,	+0x0e,	+0x12,	+0x1f,	+0x21 },	//马
RookDir[8] = { -0x01,		+0x01,	-0x10,	+0x10,	0,		0,		0,		0 },		//车
CannonDir[8] = { -0x01,		+0x01,	-0x10,	+0x10,	0,		0,		0,		0 },		//炮
PawnDir[2][8] = {
	{ -0x01,		+0x01,	-0x10,	0,		0,		0,		0,		0 },
	{ -0x01,		+0x01,	+0x10,	0,		0,		0,		0,		0 }
};		//兵

short KnightCheck[8] = { -0x10,-0x10,-0x01,+0x01,-0x01,+0x01,+0x10,+0x10 };//马腿位置
short BishopCheck[8] = { -0x11,-0x0f,+0x0f,+0x11,0,0,0,0 };	//象眼位置
short kingpalace[9] = { 54,55,56,70,71,72,86,87,88 };	//黑方九宫位置

														//各种棋子合理位置数组
unsigned char LegalPosition[2][256] = {
	{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 1,25, 1, 9, 1,25, 1, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 1, 9, 1, 9, 1, 9, 1, 9, 0, 0, 0, 0,
		0, 0, 0, 17, 1, 1, 7, 19, 7, 1, 1, 17, 0, 0, 0, 0,
		0, 0, 0, 1, 1, 1, 3, 7, 3, 1, 1, 1, 0, 0, 0, 0,
		0, 0, 0, 1, 1, 17, 7, 3, 7, 17, 1, 1, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	},
	{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 1, 1, 17, 7, 3, 7, 17, 1, 1, 0, 0, 0, 0,
		0, 0, 0, 1, 1, 1, 3, 7, 3, 1, 1, 1, 0, 0, 0, 0,
		0, 0, 0, 17, 1, 1, 7, 19, 7, 1, 1, 17, 0, 0, 0, 0,
		0, 0, 0, 9, 1, 9, 1, 9, 1, 9, 1, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 1,25, 1, 9, 1,25, 1, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	}
};
unsigned char PositionMask[7] = { 2, 4, 16, 1, 1, 1, 8 };

//估值相关数组
const char PieceNumToType[48] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 6,
	0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 6
};

const unsigned char PositionValues[2][7][256] =
{
	{
		{ // 帅(将)
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 10, 10, 10,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 15, 20, 15,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{ // 仕(士)
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 30,  0, 30,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0, 22,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 30,  0, 30,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{ // 相(象)
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0, 25,  0,  0,  0, 25,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 20,  0,  0,  0, 35,  0,  0,  0, 20,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0, 30,  0,  0,  0, 30,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{// 马
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 70, 80, 90, 80, 70, 80, 90, 80, 70,  0,  0,  0,  0,
			0,  0,  0, 80,110,125, 90, 70, 90,125,110, 80,  0,  0,  0,  0,
			0,  0,  0, 90,100,120,125,120,125,120,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100,120,130,110,130,120,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,110,110,120,100,120,110,110, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100,100,110,100,110,100,100, 90,  0,  0,  0,  0,
			0,  0,  0, 80, 90,100,100, 90,100,100, 90, 80,  0,  0,  0,  0,
			0,  0,  0, 80, 80, 90, 90, 80, 90, 90, 80, 80,  0,  0,  0,  0,
			0,  0,  0, 70, 75, 75, 70, 50, 70, 75, 75, 70,  0,  0,  0,  0,
			0,  0,  0, 60, 70, 75, 70, 60, 70, 75, 70, 60,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},

		{ // 车
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,160,170,160,150,150,150,160,170,160,  0,  0,  0,  0,
			0,  0,  0,170,180,170,190,250,190,170,180,170,  0,  0,  0,  0,
			0,  0,  0,170,190,200,220,240,220,200,190,170,  0,  0,  0,  0,
			0,  0,  0,180,220,210,240,250,240,210,220,180,  0,  0,  0,  0,
			0,  0,  0,180,220,210,240,250,240,210,220,180,  0,  0,  0,  0,
			0,  0,  0,180,220,210,240,250,240,210,220,180,  0,  0,  0,  0,
			0,  0,  0,170,190,180,220,240,220,200,190,170,  0,  0,  0,  0,
			0,  0,  0,170,180,170,170,160,170,170,180,170,  0,  0,  0,  0,
			0,  0,  0,160,170,160,160,150,160,160,170,160,  0,  0,  0,  0,
			0,  0,  0,150,160,150,160,150,160,150,160,150,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{ // 炮
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,125,130,100, 70, 60, 70,100,130,125,  0,  0,  0,  0,
			0,  0,  0,110,125,100, 70, 60, 70,100,125,110,  0,  0,  0,  0,
			0,  0,  0,100,120, 90, 80, 80, 80, 90,120,100,  0,  0,  0,  0,
			0,  0,  0, 90,110, 90,110,130,110, 90,110, 90,  0,  0,  0,  0,
			0,  0,  0, 90,110, 90,110,130,110, 90,110, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100, 90,110,130,110, 90,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100, 90, 90,110, 90, 90,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100, 80, 80, 70, 80, 80,100, 90,  0,  0,  0,  0,
			0,  0,  0, 80, 90, 80, 70, 65, 70, 80, 90, 80,  0,  0,  0,  0,
			0,  0,  0, 80, 90, 80, 70, 60, 70, 80, 90, 80,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{ // 兵(卒)
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 10, 10, 10, 20, 25, 20, 10, 10, 10,  0,  0,  0,  0,
			0,  0,  0, 25, 30, 40, 50, 60, 50, 40, 30, 25,  0,  0,  0,  0,
			0,  0,  0, 25, 30, 30, 40, 40, 40, 30, 30, 25,  0,  0,  0,  0,
			0,  0,  0, 20, 25, 25, 30, 30, 30, 25, 25, 20,  0,  0,  0,  0,
			0,  0,  0, 15, 20, 20, 20, 20, 20, 20, 20, 15,  0,  0,  0,  0,
			0,  0,  0, 10,  0, 15,  0, 15,  0, 15,  0, 10,  0,  0,  0,  0,
			0,  0,  0, 10,  0, 10,  0, 15,  0, 10,  0, 10,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		}
	},
	{
		{//黑将
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 15, 20, 15,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 10, 10, 10,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{//黑士
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 30,  0, 30,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0, 22,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 30,  0, 30,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{//黑象
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0, 30,  0,  0,  0, 30,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 20,  0,  0,  0, 35,  0,  0,  0, 20,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0, 25,  0,  0,  0, 25,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{//黑马
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 60, 70, 75, 70, 60, 70, 75, 70, 60,  0,  0,  0,  0,
			0,  0,  0, 70, 75, 75, 70, 50, 70, 75, 75, 70,  0,  0,  0,  0,
			0,  0,  0, 80, 80, 90, 90, 80, 90, 90, 80, 80,  0,  0,  0,  0,
			0,  0,  0, 80, 90,100,100, 90,100,100, 90, 80,  0,  0,  0,  0,
			0,  0,  0, 90,100,100,110,100,110,100,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,110,110,120,100,120,110,110, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100,120,130,110,130,120,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100,120,125,120,125,120,100, 90,  0,  0,  0,  0,
			0,  0,  0, 80,110,125, 90, 70, 90,125,110, 80,  0,  0,  0,  0,
			0,  0,  0, 70, 80, 90, 80, 70, 80, 90, 80, 70,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{//黑车
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,150,160,150,160,150,160,150,160,150,  0,  0,  0,  0,
			0,  0,  0,160,170,160,160,150,160,160,170,160,  0,  0,  0,  0,
			0,  0,  0,170,180,170,170,160,170,170,180,170,  0,  0,  0,  0,
			0,  0,  0,170,190,200,220,240,220,180,190,170,  0,  0,  0,  0,
			0,  0,  0,180,220,210,240,250,240,210,220,180,  0,  0,  0,  0,
			0,  0,  0,180,220,210,240,250,240,210,220,180,  0,  0,  0,  0,
			0,  0,  0,180,220,210,240,250,240,210,220,180,  0,  0,  0,  0,
			0,  0,  0,170,190,200,220,240,220,200,190,170,  0,  0,  0,  0,
			0,  0,  0,170,180,170,190,250,190,170,180,170,  0,  0,  0,  0,
			0,  0,  0,160,170,160,150,150,150,160,170,160,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{//黑炮
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 80, 90, 80, 70, 60, 70, 80, 90, 80,  0,  0,  0,  0,
			0,  0,  0, 80, 90, 80, 70, 65, 70, 80, 90, 80,  0,  0,  0,  0,
			0,  0,  0, 90,100, 80, 80, 70, 80, 80,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100, 90, 90,110, 90, 90,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100, 90,110,130,110, 90,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,110, 90,110,130,110, 90,110, 90,  0,  0,  0,  0,
			0,  0,  0, 90,110, 90,110,130,110, 90,110, 90,  0,  0,  0,  0,
			0,  0,  0,100,120, 90, 80, 80, 80, 90,120,100,  0,  0,  0,  0,
			0,  0,  0,110,125,100, 70, 60, 70,100,125,110,  0,  0,  0,  0,
			0,  0,  0,125,130,100, 70, 60, 70,100,130,125,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{//黑兵
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 10,  0, 10,  0, 15,  0, 10,  0, 10,  0,  0,  0,  0,
			0,  0,  0, 10,  0, 15,  0, 15,  0, 15,  0, 10,  0,  0,  0,  0,
			0,  0,  0, 15, 20, 20, 20, 20, 20, 20, 20, 15,  0,  0,  0,  0,
			0,  0,  0, 20, 25, 25, 30, 30, 30, 25, 25, 20,  0,  0,  0,  0,
			0,  0,  0, 25, 30, 30, 40, 40, 40, 30, 30, 25,  0,  0,  0,  0,
			0,  0,  0, 25, 30, 40, 50, 60, 50, 40, 30, 25,  0,  0,  0,  0,
			0,  0,  0, 10, 10, 10, 20, 25, 20, 10, 10, 10,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		}
	}
};

//---------------函数实现-------------------------------------------
CBoard::CBoard()
{
	side = 0;
	StackTop = 0;
	DepthNow = 0;
	MaxDepth = 4;


}

CBoard::~CBoard()
{

}
void  CBoard::StringToArray(const char *FenStr)// 将FEN串表示的局面转换成一维数组
{
	int i, j, k;
	int pcWhite[7] = { 16,17,19,21,23,25,27 };
	int pcBlack[7] = { 32,33,35,37,39,41,43 };
	const char *str;

	ClearBoard();
	str = FenStr;
	if (*str == '\0')
	{
		return;
	}

	i = 3;
	j = 3;
	while (*str != ' ')
	{
		if (*str == '/')
		{
			j = 3;
			i++;
			if (i > 12)
			{
				break;
			}
		}
		else if (*str >= '1' && *str <= '9')
		{
			for (k = 0; k < (*str - '0'); k++)
			{
				if (j >= 11)
				{
					break;
				}
				j++;
			}
		}
		else if (*str >= 'A' && *str <= 'Z')
		{
			if (j <= 11)
			{
				k = CharToSubscript(*str);
				if (k < 7)
				{
					if (pcWhite[k] < 32)
					{
						AddPiece((i << 4) + j, pcWhite[k]);
						pcWhite[k]++;
					}
				}
				j++;
			}
		}
		else if (*str >= 'a' && *str <= 'z')
		{
			if (j <= 11)
			{
				k = CharToSubscript(*str);
				if (k < 7)
				{
					if (pcBlack[k] < 48)
					{
						AddPiece((i << 4) + j, pcBlack[k]);
						pcBlack[k]++;
					}
				}
				j++;
			}
		}

		str++;
		if (*str == '\0')
		{
			return;
		}
	}
	str++;

	if (*str == 'b')
		side = 1;
	else
		side = 0;
}

int CBoard::CharToSubscript(char ch)
{
	switch (ch)
	{
	case 'k':
	case 'K':return 0;
	case 'a':
	case 'A':return 1;
	case 'b':
	case 'B':return 2;
	case 'n':
	case 'N':return 3;
	case 'r':
	case 'R':return 4;
	case 'c':
	case 'C':return 5;
	case 'p':
	case 'P':return 6;
	default:return 7;
	}
}

void CBoard::AddPiece(int pos, int pc) //增加棋子
{
	board[pos] = pc;
	piece[pc] = pos;
}

void CBoard::ClearBoard()
{
	int i;
	side = 0;
	unsigned char piece1[48] = {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		199,198,200,197,201,196,202,195,203,164,170,147,149,151,153,155,
		55,54,56,53,57,52,58,51,59,84,90,99,101,103,105,107
	};
	for (i = 0; i < 48; i++) {
		piece[i] = piece1[i];
	}
	unsigned char board1[256] = {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,39,37,35,33,32,34,36,38,40,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,41,0,0,0,0,0,42,0,0,0,0,0,
		0,0,0,43,0,44,0,45,0,46,0,47,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,27,0,28,0,29,0,30,0,31,0,0,0,0,
		0,0,0,0,25,0,0,0,0,0,26,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,23,21,19,17,16,18,20,22,24,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	};
	for (i = 0; i < 258; i++) board[i] = board1[i];
}

void CBoard::addPiece(int pos, int pc) //在pos处插入棋子pc
{
	piece[pc] = pos;
	board[pos] = pc;
}

int CBoard::GenAllMove(Move *MoveArray)
{
	short i, j, k;
	unsigned char p;	//p:棋子位置
	unsigned char n;	//下一步可能行走的位置
	unsigned char m;	//马腿、象眼位置
	int SideTag;		//走棋方，经方16，黑方32
	int OverFlag;		//炮的翻山标志
	Move * mvArray = MoveArray;

	SideTag = 16 + 16 * side;

	p = piece[SideTag];	//将的位置
	if (!p)
		return 0;

	//将的走法
	for (k = 0; k<4; k++)//4个方向
	{
		n = p + KingDir[k];	//n为新的可能走到的位置
		if (LegalPosition[side][n] & PositionMask[0])	//将对应下标为0
		{
			if (!(board[n] & SideTag))	//目标位置上没有本方棋子
				if (saveMove(p, n, mvArray))
					mvArray++;
		}
	}

	//士的走法
	for (i = 1; i <= 2; i++)
	{
		p = piece[SideTag + i];
		if (!p)
			continue;
		for (k = 0; k<4; k++)//4个方向
		{
			n = p + AdvisorDir[k];	//n为新的可能走到的位置
			if (LegalPosition[side][n] & PositionMask[1])	//士将对应下标为1
			{
				if (!(board[n] & SideTag))	//目标位置上没有本方棋子
					if (saveMove(p, n, mvArray))
						mvArray++;
			}
		}
	}

	//象的走法
	for (i = 3; i <= 4; i++)
	{
		p = piece[SideTag + i];
		if (!p)
			continue;
		for (k = 0; k<4; k++)//4个方向
		{
			n = p + BishopDir[k];	//n为新的可能走到的位置
			if (LegalPosition[side][n] & PositionMask[2])	//象将对应下标为2
			{
				m = p + BishopCheck[k];
				if (!board[m])	//象眼位置无棋子占据
				{
					if (!(board[n] & SideTag))	//目标位置上没有本方棋子
						if (saveMove(p, n, mvArray))
							mvArray++;
				}
			}
		}
	}

	//马的走法
	for (i = 5; i <= 6; i++)
	{
		p = piece[SideTag + i];
		if (!p)
			continue;
		for (k = 0; k<8; k++)//8个方向
		{
			n = p + KnightDir[k];	//n为新的可能走到的位置
			if (LegalPosition[side][n] & PositionMask[3])	//马将对应下标为3
			{
				m = p + KnightCheck[k];
				if (!board[m])	//马腿位置无棋子占据
				{
					if (!(board[n] & SideTag))	//目标位置上没有本方棋子
						if (saveMove(p, n, mvArray))
							mvArray++;
				}
			}
		}
	}

	//车的走法
	for (i = 7; i <= 8; i++)
	{
		p = piece[SideTag + i];
		if (!p)
			continue;
		for (k = 0; k<4; k++)	//4个方向
		{
			for (j = 1; j<10; j++)	//横的最多有8个可能走的位置，纵向最多有9个位置
			{
				n = p + j * RookDir[k];
				if (!(LegalPosition[side][n] & PositionMask[4]))	//车士将对应下标为4
					break;//不合理的位置
				if (!board[n])	//目标位置上无子
				{
					if (saveMove(p, n, mvArray))
						mvArray++;
				}
				else if (board[n] & SideTag)	//目标位置上有本方棋子
					break;
				else	//目标位置上有对方棋子
				{
					if (saveMove(p, n, mvArray))
						mvArray++;
					break;
				}
			}
		}
	}

	//炮的走法
	for (i = 9; i <= 10; i++)
	{
		p = piece[SideTag + i];
		if (!p)
			continue;
		for (k = 0; k<4; k++)	//4个方向
		{
			OverFlag = 0;
			for (j = 1; j<10; j++)	//横的最多有8个可能走的位置，纵向最多有9个位置
			{
				n = p + j * CannonDir[k];
				if (!(LegalPosition[side][n] & PositionMask[5]))	//炮士将对应下标为5
					break;//不合理的位置
				if (!board[n])	//目标位置上无子
				{
					if (!OverFlag)	//未翻山
						if (saveMove(p, n, mvArray))
							mvArray++;
					//已翻山则不作处理，自动考察向下一个位置
				}
				else//目标位置上有子
				{
					if (!OverFlag)	//未翻山则置翻山标志
						OverFlag = 1;
					else	//已翻山
					{
						if (!(board[n] & SideTag))//对方棋子
							if (saveMove(p, n, mvArray))
								mvArray++;
						break;	//不论吃不吃子，都退出此方向搜索
					}
				}
			}
		}
	}

	//兵的走法
	for (i = 11; i <= 15; i++)
	{
		p = piece[SideTag + i];
		if (!p)
			continue;
		for (k = 0; k<3; k++)//3个方向
		{
			n = p + PawnDir[side][k];	//n为新的可能走到的位置
			if (LegalPosition[side][n] & PositionMask[6])	//兵士将对应下标为6
			{
				if (!(board[n] & SideTag))	//目标位置上没有本方棋子
					if (saveMove(p, n, mvArray))
						mvArray++;
			}
		}
	}
	return mvArray - MoveArray;
}

void CBoard::ChangeSide()
{
	side = 1 - side;
}


int CBoard::Check(int lSide)
{
	unsigned char wKing, bKing; //红黑双方将帅的位置
	unsigned char p, q;
	int r;	//r=1表示将军，否则为0
	int SideTag = 32 - lSide * 16;	//此处表示lSide对方的将的值
	int fSide = 1 - lSide;	//对方标志
	int i;
	int PosAdd;	//位置增量

	wKing = piece[16];
	bKing = piece[32];
	if (!wKing || !bKing)
		return 0;

	//检测将帅是否照面
	r = 1;
	if (wKing % 16 == bKing % 16)
	{
		for (wKing = wKing - 16; wKing != bKing; wKing = wKing - 16)
		{
			if (board[wKing])
			{
				r = 0;
				break;
			}
		}
		if (r)
			return r;	//将帅照面
	}

	q = piece[48 - SideTag];	//lSide方将的位置

								//检测将是否被马攻击
	int k;
	unsigned char n;//下一步可能行走的位置
	unsigned char m;//马腿位置

	for (i = 5; i <= 6; i++)
	{
		p = piece[SideTag + i];
		if (!p)
			continue;
		for (k = 0; k<8; k++)//8个方向
		{
			n = p + KnightDir[k];	//n为新的可能走到的位置
			if (n != q)
				continue;

			if (LegalPosition[fSide][n] & PositionMask[3])	//马将对应下标为3
			{
				m = p + KnightCheck[k];
				if (!board[m])	//马腿位置无棋子占据
				{
					return 1;
				}
			}
		}
	}

	//检测将是否被车攻击
	r = 1;
	for (i = 7; i <= 8; i++)
	{
		p = piece[SideTag + i];
		if (!p)
			continue;
		if (p % 16 == q % 16)	//在同一纵线上
		{
			PosAdd = (p>q ? -16 : 16);
			for (p = p + PosAdd; p != q; p = p + PosAdd)
			{
				if (board[p])	//车将中间有子隔着
				{
					r = 0;
					break;
				}
			}
			if (r)
				return r;
		}
		else if (p / 16 == q / 16)	//在同一横线上
		{
			PosAdd = (p>q ? -1 : 1);
			for (p = p + PosAdd; p != q; p = p + PosAdd)
			{
				if (board[p])
				{
					r = 0;
					break;
				}
			}
			if (r)
				return r;
		}
	}

	//检测将是否被炮攻击
	int OverFlag = 0;	//翻山标志
	for (i = 9; i <= 10; i++)
	{
		p = piece[SideTag + i];
		if (!p)
			continue;
		if (p % 16 == q % 16)	//在同一纵线上
		{
			PosAdd = (p>q ? -16 : 16);
			for (p = p + PosAdd; p != q; p = p + PosAdd)
			{
				if (board[p])
				{
					if (!OverFlag)	//隔一子
						OverFlag = 1;
					else			//隔两子
					{
						OverFlag = 2;
						break;
					}
				}
			}
			if (OverFlag == 1)
				return 1;
		}
		else if (p / 16 == q / 16)	//在同一横线上
		{
			PosAdd = (p>q ? -1 : 1);
			for (p = p + PosAdd; p != q; p = p + PosAdd)
			{
				if (board[p])
				{
					if (!OverFlag)
						OverFlag = 1;
					else
					{
						OverFlag = 2;
						break;
					}
				}
			}
			if (OverFlag == 1)
				return 1;
		}
	}

	//检测将是否被兵攻击
	for (i = 11; i <= 15; i++)
	{
		p = piece[SideTag + i];
		if (!p)
			continue;
		for (k = 0; k<3; k++)//3个方向
		{
			n = p + PawnDir[fSide][k];	//n为新的可能走到的位置
			if ((n == q) && (LegalPosition[fSide][n] & PositionMask[6]))	//兵士将对应下标为6
			{
				return 1;
			}
		}
	}

	return 0;
}

int CBoard::saveMove(unsigned char from, unsigned char to, Move *mv)
{
	unsigned char p;

	p = board[to];
	piece[board[from]] = to;
	if (p)
		piece[p] = 0;
	board[to] = board[from];
	board[from] = 0;

	int r = Check(side);
	board[from] = board[to];
	board[to] = p;
	piece[board[from]] = from;
	if (p)
		piece[p] = to;

	if (!r)
	{
		mv->from = from;
		mv->to = to;
		return 1;
	}
	return 0;
}

int CBoard::NegaMaxSearch(int depth, int alpha, int beta) //极大极小值搜索
{
	int value;
	Move MoveArray[128];
	Move mv;
	int i;

	if (depth == 0)
		return eval();

	int num = GenAllMove(MoveArray);
	for (i = 0; i<num; i++)
	{
		mv = MoveArray[i];
		MakeMove(mv);
		value = -NegaMaxSearch(depth - 1, -beta, -alpha);
		UnMakeMove();
		if (value >= beta)
			return beta;
		if (value > alpha)
		{
			alpha = value;
			if (depth == MaxDepth)
				BestMove = mv;
		}
	}
	return alpha;
}

bool CBoard::MakeMove(Move m)
{
	unsigned char from, dest, p;
	int SideTag = (side == 0 ? 32 : 16);	//此处为对方将帅的值，其它地方多表示本方将帅值

	from = m.from;
	dest = m.to;

	//设置走法栈
	MoveStack[StackTop].from = from;
	MoveStack[StackTop].to = dest;
	MoveStack[StackTop].capture = p = board[dest];
	StackTop++;

	//设置棋子数组
	if (p>0)
		piece[p] = 0;
	piece[board[from]] = dest;

	//设置棋盘数组
	board[dest] = board[from];
	board[from] = 0;

	DepthNow++;

	ChangeSide();

	return p == SideTag;
}

void CBoard::UnMakeMove()
{
	unsigned char from, dest, p;

	StackTop--;
	DepthNow--;

	ChangeSide();

	from = MoveStack[StackTop].from;
	dest = MoveStack[StackTop].to;
	p = MoveStack[StackTop].capture;

	//设置棋盘数组
	board[from] = board[dest];
	board[dest] = p;

	//设置棋子数组
	if (p>0)
		piece[p] = dest;
	piece[board[from]] = from;

}


//估值函数 越大 红方越有利

short CBoard::eval()
{
	short i, j, k, r;
	unsigned char p;	//p:棋子位置
	unsigned char n;	//下一步可能行走的位置
	unsigned char m;	//马腿、象眼位置
	int SideTag;		//走棋方，红方16，黑方32
	int OverFlag;		//炮的翻山标志
	short bValue, wValue;
	short fValue[2] = { 0,0 };	//灵活性分值
	bValue = wValue = 0;

	//计算固定位置分值
	for (i = 16; i<32; i++)
	{
		if (piece[i]>0)
			wValue = wValue + PositionValues[0][PieceNumToType[i]][piece[i]];
	}

	for (i = 32; i<48; i++)
	{
		if (piece[i]>0)
			bValue = bValue + PositionValues[1][PieceNumToType[i]][piece[i]];
	}


	//计算灵活性分值
	for (r = 0; r <= 1; r++)
	{
		SideTag = 16 + 16 * r;
		p = piece[SideTag];
		//将的灵活性
		for (k = 0; k<4; k++)//4个方向
		{
			n = p + KingDir[k];	//n为新的可能走到的位置
			if (LegalPosition[side][n] & PositionMask[0])	//将对应下标为0
			{
				if (!(board[n] & SideTag))	//目标位置上没有本方棋子
					fValue[r] += 2;
			}
		}

		//士的灵活性
		for (i = 1; i <= 2; i++)
		{
			p = piece[SideTag + i];
			if (!p)
				continue;
			for (k = 0; k<4; k++)//4个方向
			{
				n = p + AdvisorDir[k];	//n为新的可能走到的位置
				if (LegalPosition[side][n] & PositionMask[1])	//士将对应下标为1
				{
					if (!(board[n] & SideTag))	//目标位置上没有本方棋子
						fValue[r] += 2;
				}
			}
		}

		//象的走法灵活性
		for (i = 3; i <= 4; i++)
		{
			p = piece[SideTag + i];
			if (!p)
				continue;
			for (k = 0; k<4; k++)//4个方向
			{
				n = p + BishopDir[k];	//n为新的可能走到的位置
				if (LegalPosition[side][n] & PositionMask[2])	//象将对应下标为2
				{
					m = p + BishopCheck[k];
					if (!board[m])	//象眼位置无棋子占据
					{
						if (!(board[n] & SideTag))	//目标位置上没有本方棋子
							fValue[r] += 2;
					}
				}
			}
		}

		//马的灵活性
		for (i = 5; i <= 6; i++)
		{
			p = piece[SideTag + i];
			if (!p)
				continue;
			for (k = 0; k<8; k++)//8个方向
			{
				n = p + KnightDir[k];	//n为新的可能走到的位置
				if (LegalPosition[side][n] & PositionMask[3])	//马将对应下标为3
				{
					m = p + KnightCheck[k];
					if (!board[m])	//马腿位置无棋子占据
					{
						if (!(board[n] & SideTag))	//目标位置上没有本方棋子
							fValue[r] += 5;
					}
				}
			}
		}

		//车的灵活性
		for (i = 7; i <= 8; i++)
		{
			p = piece[SideTag + i];
			if (!p)
				continue;
			for (k = 0; k<4; k++)	//4个方向
			{
				for (j = 1; j<10; j++)	//横的最多有8个可能走的位置，纵向最多有9个位置
				{
					n = p + j * RookDir[k];
					if (!(LegalPosition[side][n] & PositionMask[4]))	//车士将对应下标为4
						break;//不合理的位置
					if (!board[n])	//目标位置上无子
					{
						fValue[r] += 4;
					}
					else if (board[n] & SideTag)	//目标位置上有本方棋子
						break;
					else	//目标位置上有对方棋子
					{
						fValue[r] += 4;
						break;
					}
				}
			}
		}

		//炮的灵活性
		for (i = 9; i <= 10; i++)
		{
			p = piece[SideTag + i];
			if (!p)
				continue;
			for (k = 0; k<4; k++)	//4个方向
			{
				OverFlag = 0;
				for (j = 1; j<10; j++)	//横的最多有8个可能走的位置，纵向最多有9个位置
				{
					n = p + j * CannonDir[k];
					if (!(LegalPosition[side][n] & PositionMask[5]))	//炮士将对应下标为5
						break;//不合理的位置
					if (!board[n])	//目标位置上无子
					{
						if (!OverFlag)	//未翻山
							fValue[r] += 3;
						//已翻山则不作处理，自动考察向下一个位置
					}
					else//目标位置上有子
					{
						if (!OverFlag)	//未翻山则置翻山标志
							OverFlag = 1;
						else	//已翻山
						{
							if (!(board[n] & SideTag))//对方棋子
								fValue[r] += 3;
							break;	//不论吃不吃子，都退出此方向搜索
						}
					}
				}
			}
		}

		//兵的灵活性
		for (i = 11; i <= 15; i++)
		{
			p = piece[SideTag + i];
			if (!p)
				continue;
			for (k = 0; k<3; k++)//3个方向
			{
				n = p + PawnDir[side][k];	//n为新的可能走到的位置
				if (LegalPosition[side][n] & PositionMask[6])	//兵士将对应下标为6
				{
					if (!(board[n] & SideTag))	//目标位置上没有本方棋子
						fValue[r] += 2;
				}
			}
		}

	}

	return fValue[0] - fValue[1] + wValue - bValue;
}

void CBoard::ComputerThink()
{
	BestMove.from = 0;
	BestMove.to = 0;

	StackTop = 0;
	DepthNow = 0;
	MaxDepth = 5;
	NegaMaxSearch(MaxDepth, -MaxValue, MaxValue);

}

int CBoard::LegalMove(Move mv)
{
	Move mvArray[128];
	int num, i;
	num = GenAllMove(mvArray);
	//if (mvArray[0].from == (unsigned char)199) cout << "fda" << endl;
	for (i = 0; i < num; i++) {
		if (mv.to == mvArray[i].to && mv.from == mvArray[i].from) return 1;
	}
	return 0;
}

int CBoard::HasLegalMove()
{
	Move mvArray[128];
	for (short i = 0; i < 128; i++)
	{
		mvArray[i].from = '\0';
		mvArray[i].to = '\0';
	}
	int num;
	num = GenAllMove(mvArray);
	return num;
}